Тезисно важные моменты из QA-сессии

- Язык разработки для логики работы сервиса С++, за исклчением того, что обсуждалось в чате.

- Сервер при первом старте имеет администратора с логином и паролем по умолчанию. После первого входа данный пароль меняется пользователем и для последующей работы сервера, используется заданный пароль. После чего пользователь может вводить команды в интерактивном режиме (создать удалить пользователя, показать список пользователей, изменить пароль, показать время).

- Между запусками приложения состояние сервера сохраняется

- В MVP сервиса централизованной авторизации достаточно включить часть сервера с CLI, GUI, содержащую реализацию функций из пункта Постановка задач. Часть клиента (с другогих устройств), которая бы обращалась к серверу по TCP, HTTP и получала ответ о разрешение прав доступа и/или ответ на выполнение команд не обязательна.

- Лучше, сначала реализоать базовый функционал MVP, чем не доделанная базовая функциональность MVP с реализованными фишками сверх задания

- Возможность разграничивать права доступа (в базовом варианте на выполнение команд) для разных групп (ролей) пользователей: admin, engineer, guest. Также будет приветствоваться гибкость решения: возможность (или легкость реализации в текущей архитектуре) создавать уникального пользователя и наделять его правами на определенные операции.

- Грамотное раграничение прав доступа. Например,  удалять, создаать пользователя и просматривать списки пользоателей может только администратор

- Для демонстрации работы ограничений, можно добавить свои простые функции, например, посмотреть текущее время, конфигурацию контроллера (условно)

- Для хэширования паролей можно использоать свой хэшер, но лучше обратиться к криптографии, например задействовать библиотеку OpenSSL

- Можно использовать сторонние библиотеки Boost, POCO и другие

- Приветствуется логирование всех запросов от пользователя и отказов в соответствии с праами доступа

- Желательно, чтобы README описывал как решение и отдельные модули, так и установку

- Кросплатформенность и сборка с помощью CMake, использование Docker-контейнера, менеджера пакетов Conan - будет плюсом

Ещё добавлю, будет здорово, если написанный функионал будет покрываться юнит-тестами. Например с использованием одного из популярных фреймворков:  Google Test, Catch 2, Boost.Test